---
import type { GetStaticPaths, MarkdownHeading, MarkdownInstance } from "astro";
import Layout from "../layouts/Layout.astro";
import type Frontmatter from "../types/frontmatter";
import path from "path";
import Navigation from "../components/Navigation.astro";
import Footer from "../components/Footer.astro";
import TreeNode from "../types/TreeNode";

type MarkdownHeadingSection = MarkdownHeading & {
  wordCount?: number;
  readTime?: number;
};

export const getStaticPaths = (() => {
  return Object.values(import.meta.glob<MarkdownInstance<Frontmatter>>('../md/*.md', { eager: true }))
    .map((post) => {
      return {
        params: {
          post: path.basename(post.file).replace('.md', ''),
        },
      };
    })
}) satisfies GetStaticPaths;

const { post : postName } = Astro.params;

const thePost = Object.values(import.meta.glob<MarkdownInstance<Frontmatter>>('../md/*.md', { eager: true }))
  .find(p => path.basename(p.file).replace('.md','') === postName);

const Content = thePost!.Content;
const frontmatter = thePost!.frontmatter;

const rawContentWithoutDetails = thePost!.rawContent().replace(/<details>[\s\S]*?<\/details>/g, '');
const readingTime = Math.ceil(rawContentWithoutDetails.split(/[^A-Za-z0-9_]+/).length / 200);

let depth = 1;
let tableOfContents = "";
const headings: MarkdownHeadingSection[] | undefined = thePost?.getHeadings();
if (headings) {
  const root = new TreeNode<MarkdownHeadingSection|null>(null);
  let curNode = root;
  for (let i = 0; i < headings.length; i++) {
    const heading = headings[i];
    const node = new TreeNode<MarkdownHeadingSection|null>(heading);
    if (heading.depth > depth) {
      depth = heading.depth;
      curNode = curNode.children[curNode.children.length-1];
    }
    else if (heading.depth < depth) {
      const diff = depth - heading.depth;
      for (let j = 0; j < diff; j++) {
        curNode = curNode.parent!;
      }
      depth = heading.depth;
    }
    curNode.addChild(node);

    const strippedRawContent = thePost?.rawContent().replace(/[^A-Za-z0-9_ #.?!]/g,'')!
    const fromIndex = strippedRawContent.indexOf('# '+heading.text.replace(/[^A-Za-z0-9_ #.?!]/g,''))!;
    const toIndex = headings[i+1] ? strippedRawContent.indexOf('# '+headings[i+1].text.replace(/[^A-Za-z0-9_ #.?!]/g,'')) : strippedRawContent.length - 1;

    heading.wordCount = strippedRawContent.substring(fromIndex, toIndex).split(/[^A-Za-z0-9_]+/).length;
    heading.readTime = Math.ceil((heading.wordCount || 0) / 200);
    let upnode = node.parent;
    while (upnode!.value != null) {
      upnode!.value!.wordCount! += heading.wordCount!;
      upnode!.value!.readTime = Math.ceil((upnode!.value!.wordCount || 0) / 200);
      upnode = upnode!.parent!;
    }
  }
  const stack: TreeNode<MarkdownHeadingSection|null>[] = [];
  stack.push(root);
  depth = 0;
  while (stack.length > 0) {
    const node = stack.pop()!;
    for (const child of node.children.toReversed()) {
      stack.push(child);
    }
    if (node.value == null) {
      continue;
    }
    if (node.value.depth > depth) {
      depth = node.value.depth;
      tableOfContents += "<ul>";
    }
    else if (node.value.depth < depth) {
      const diff = depth - node.value.depth;
      for (let j = 0; j < diff; j++) {
        tableOfContents += "</ul>";
      }
      depth = node.value.depth;
    }
    tableOfContents += `<li><a href="#${node.value.slug}">${node.value.text}</a><span class="sectionTime">${node.value.readTime || 0}</span></li>`;
  }
}
---

<style>
  .container {
		max-width: 55rem;
		margin: auto;
    padding: 1rem;
    padding-top: 0;
	}
  #scrollToTop {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    border: none;
    background: transparent;
    color: var(--theme-bright-text-color);
    font-size: 3rem;
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    z-index: 1000;
    transform: scale(calc(1 / var(--zoom)));
    transition: color 0.3s ease;
  }
  #scrollToTop.show {
    opacity: 1;
    visibility: visible;
  }
  @keyframes bounce-up {
    0%, 100% { transform: translateY(0) scale(calc(1 / var(--zoom))); }
    50% { transform: translateY(-5px) scale(calc(1 / var(--zoom))); }
  }
  #scrollToTop:hover {
    animation: bounce-up 0.3s ease;
    color: var(--purple-light);
  }
  #timeinfo {
    display: flex;
    justify-content: space-between;
  }
  .lastModified,
  .readingTime {
    font-size: 0.9em;
    color: #737373;
  }
  .readingTime::before {
    content: "⏳ ";
  }
</style>

<style is:global>
  #table-of-contents h3 {
    text-align: center;
  }
  #table-of-contents {
    /* display flex is in inline css */
    align-items: center;

    position: fixed;
    padding-left: 1rem;
    padding-right: 2rem;
    max-width: 100%;
    background-color: var(--theme-background-color);
    border-radius: 1rem 0 0 1rem;

    transform: translateX(100%);
    transition: transform 0.2s ease-in-out, right 0.2s ease-in-out;

    right: 3rem;
    border: 1px solid var(--purple-light);

    @media screen and (max-width: 75rem) {
      display: none !important;
    }
  }
  #table-of-contents:hover {
    right: -1px;
    transform: translateX(0);
  }
  #table-of-contents .leftarrow {
    color: var(--theme-bright-text-color);
    font-size: 1.5em;
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
  }
  #table-of-contents:hover .leftarrow {
    opacity: 0;
  }
  #table-of-contents ul {
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
  }
  #table-of-contents:hover ul {
    opacity: 1;
  }
  #table-of-contents.keep-showing {
    right: -1px;
    transform: translateX(100%);
  }

  #static-table-of-contents {
    border-radius: 1rem;
    border: 1px solid var(--purple-light);
  }

  #static-table-of-contents h3 {
    padding-left: 1.3rem;
  }

  span.sectionTime {
    font-size: 0.7em;
    color: #737373;
    padding-left: .5rem;
  }

  span.sectionTime::before {
    content: "~";
  }

  span.sectionTime::after {
    content: " min";
  }
</style>

<Layout title={frontmatter.title}>
  <div>
    <Navigation title={frontmatter.title}/>

    <div id="table-of-contents" class="keep-showing" style=`display: ${frontmatter.article && tableOfContents != "" ? "flex" : "none"}`>
      <div>
        <p class="leftarrow">❮</p>
      </div>
      <div>
        <h3>Table of contents</h3>
        <div id="table-of-contents-content" set:html={tableOfContents}></div>
      </div>
    </div>
    
    <div class="container">
      <div class="float">
        <button id="scrollToTop" aria-label="Scroll to top" title="Scroll to top">^</button>
      </div>
      <div id="timeinfo">
        <p class="readingTime">
          {frontmatter.article &&
            <span>~{readingTime} minute read</span>
          }
        </p>
        <p class="lastModified">
          {frontmatter.modified && 
            <span>{frontmatter.modified}</span>
          }
        </p>
      </div>
      {frontmatter.article && tableOfContents != "" &&
        <div id="static-table-of-contents">
          <h3>Table of contents</h3>
          <div set:html={tableOfContents}></div>
        </div>
      }
      <Content/>
    </div>
    <Footer />
  </div>
</Layout>

<script is:inline data-astro-rerun>
  btn = document.getElementById("scrollToTop");
  goBackButton = document.getElementById("goBackButton");
  tableOfContentsElement = document.getElementById("table-of-contents");

  window.addEventListener("scroll", () => {
    if (window.scrollY > 500) {
      btn.classList.add("show");
    } else {
      btn.classList.remove("show");
    }
    if (window.scrollY > 50) {
      goBackButton.classList.remove("outline-on-hover")
    } else {
      goBackButton.classList.add("outline-on-hover")
    }
    if (window.scrollY > 50) {
      tableOfContentsElement.classList.remove("keep-showing")
    } else {
      tableOfContentsElement.classList.add("keep-showing")
    }
  });

  btn.addEventListener("click", () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  });
</script>